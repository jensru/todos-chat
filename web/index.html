<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Task Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="ui-guidelines.js"></script>
    <script src="date-sync.js"></script>
    <style>
        /* Import Google Sans */
        @import url('https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;600&display=swap');
        
        /* CSS Custom Properties - UI Guidelines */
        :root {
            /* Primary Colors */
            --primary: #0B57D0;
            --primary-hover: #0a4bb8;
            --primary-light: #e8f0fe;
            
            /* Secondary Colors */
            --secondary: #5f6368;
            --secondary-hover: #3c4043;
            --secondary-light: #f1f3f4;
            
            /* Highlight Color - Only Red */
            --highlight: #d93025;
            --highlight-hover: #b52d20;
            --highlight-light: #ffebee;
            
            /* Text Colors */
            --text-primary: #1f1f1f;
            --text-secondary: #444746;
            --text-tertiary: #747775;
            --text-disabled: #9aa0a6;
            
            /* Background Colors */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e8f0fe;
            
            /* Border Colors */
            --border-light: #e8eaed;
            --border-medium: #dadce0;
            --border-dark: #bdc1c6;
            
            /* Spacing System (8px Grid) */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;
            --space-12: 48px;
            --space-16: 64px;
            
            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.15);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.2);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.5;
        }
        
        .main-container {
            display: flex;
            height: 100vh;
        }
        
        /* Smart Task Dashboard - Left Side */
        .smart-dashboard {
            flex: 1;
            padding: var(--space-6);
            background: var(--bg-primary);
            overflow-y: auto;
        }
        
        .header {
            margin-bottom: var(--space-6);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .header-left h1 {
            color: var(--primary);
            font-size: 32px;
            font-weight: 600;
            margin: 0 0 var(--space-2) 0;
        }
        
        .header-left p {
            color: var(--text-secondary);
            font-size: 14px;
            margin: 0;
        }
        
        .header-right {
            text-align: right;
        }
        
        .current-date {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }
        
        /* Filter Buttons */
        .filter-buttons {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-6);
            flex-wrap: wrap;
        }
        
        /* Filter & Sortierung Bar */
        .filter-sort-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-4);
            padding: var(--space-3) 0;
            border-bottom: 1px solid var(--border-light);
        }

        .filter-section {
            display: flex;
            gap: var(--space-2);
        }

        .sort-section {
            display: flex;
            gap: var(--space-2);
        }

        .filter-btn {
            padding: var(--space-3) var(--space-4);
            border: 1px solid var(--border-medium);
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: var(--text-primary);
            border-radius: var(--radius-lg);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }

        .filter-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .filter-btn:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .filter-btn:hover::before {
            left: 100%;
        }

        .filter-btn.active {
            background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
            color: white;
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
            transform: translateY(-1px);
        }

        .sort-btn {
            padding: var(--space-3) var(--space-4);
            border: 1px solid var(--border-medium);
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: var(--text-primary);
            border-radius: var(--radius-lg);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }

        .sort-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .sort-btn:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: var(--secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .sort-btn:hover::before {
            left: 100%;
        }

        .sort-btn.active {
            background: linear-gradient(135deg, var(--secondary) 0%, #495057 100%);
            color: white;
            border-color: var(--secondary);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
            transform: translateY(-1px);
        }
        .smart-task-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: var(--space-3);
            min-width: 0;
            overflow: hidden;
            min-height: 50px;
            max-height: 50px;
            width: 100%;
            max-width: 100%;
        }
        
        .smart-task-card:hover {
            border-color: var(--primary);
            box-shadow: var(--shadow-sm);
        }

        /* Editable Elements */
        .task-title-editable {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1);
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .priority-editable,
        .category-editable,
        .due-date-editable {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1);
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            flex-shrink: 0; /* Prevents these elements from shrinking */
            white-space: nowrap; /* Prevents text wrapping in these elements */
        }

        .task-title-editable:hover,
        .priority-editable:hover,
        .category-editable:hover,
        .due-date-editable:hover {
            background-color: var(--bg-secondary);
            transform: scale(1.02);
        }

        .edit-hint {
            opacity: 0;
            font-size: 12px;
            transition: opacity 0.2s ease;
            color: var(--text-tertiary);
        }

        .task-title-editable:hover .edit-hint,
        .priority-editable:hover .edit-hint,
        .category-editable:hover .edit-hint,
        .due-date-editable:hover .edit-hint {
            opacity: 1;
        }

        .task-title-text {
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
            min-width: 0;
        }

        /* Context Menu Styles */
        .context-menu {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            padding: var(--space-2);
            z-index: 1000;
            min-width: 150px;
        }

        .context-menu-item {
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .context-menu-item:hover {
            background-color: var(--bg-secondary);
        }

        .context-menu-item.danger {
            color: var(--highlight);
        }

        .context-menu-item.danger:hover {
            background-color: var(--highlight-light);
        }
        
        .task-content {
            flex: 1;
        }
        
        .task-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin: 0;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .task-checkbox {
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            flex-shrink: 0;
        }
        
        .task-checkbox:hover {
            transform: scale(1.1);
        }
        
        .category-drop-zone {
            min-height: 20px;
            padding: var(--space-1);
            border-radius: var(--radius-sm);
            transition: background-color 0.2s ease;
        }
        
        .category-drop-zone:hover {
            background: var(--secondary-light);
        }
        
        .task-meta {
            display: flex;
            gap: var(--space-2);
            align-items: center;
            flex-shrink: 0;
        }
        
        .priority-badge {
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .priority-high {
            background: var(--highlight-light);
            color: var(--highlight);
        }
        
        .priority-medium {
            background: var(--secondary-light);
            color: var(--secondary);
        }
        
        .priority-low {
            background: var(--secondary-light);
            color: var(--text-tertiary);
        }
        
        .deadline-badge {
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .deadline-overdue {
            background: var(--highlight-light);
            color: var(--highlight);
        }
        
        .deadline-due-today {
            background: var(--primary-light);
            color: var(--primary);
        }
        
        .deadline-due-tomorrow {
            background: var(--secondary-light);
            color: var(--secondary);
        }
        
        .delete-task-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: var(--space-1);
            border-radius: var(--radius-sm);
            opacity: 0.6;
            transition: all 0.2s ease;
            flex-shrink: 0; /* Prevents delete button from shrinking */
        }
        
        .delete-task-btn:hover {
            opacity: 1;
            background: var(--highlight-light);
            transform: scale(1.1);
        }
        
        .deadline-due-soon {
            background: var(--secondary-light);
            color: var(--secondary);
        }
        
        .task-tags {
            display: flex;
            gap: var(--space-1);
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .task-tag {
            background: var(--primary-light);
            color: var(--primary);
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 500;
        }
        
        .due-date-display {
            margin-top: var(--space-1);
            padding: var(--space-1) var(--space-2);
            background: var(--secondary-light);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            border-left: 2px solid var(--primary);
            white-space: nowrap;
        }
        
        .task-stats {
            display: flex;
            gap: var(--space-2);
            align-items: center;
            font-size: 12px;
            color: var(--text-tertiary);
            flex-shrink: 0; /* Prevents task stats from shrinking */
            white-space: nowrap; /* Prevents text wrapping */
        }
        
        /* Completed Task Styling */
        .completed-task {
            opacity: 0.8;
            background: var(--bg-secondary) !important;
            border-color: var(--border-light) !important;
            cursor: default !important;
        }
        
        .completed-task:hover {
            border-color: var(--border-light) !important;
            box-shadow: none !important;
        }
        
        .completed-task .task-title {
            color: var(--text-tertiary) !important;
            text-decoration: line-through;
        }
        
        .completed-task .priority-badge,
        .completed-task .deadline-badge {
            opacity: 0.7;
        }
        
        .completed-task .due-date-display {
            background: var(--bg-primary) !important;
            border-left-color: var(--border-light) !important;
            color: var(--text-tertiary) !important;
        }
        
        .completed-task .task-stats {
            color: var(--text-tertiary) !important;
        }
        
        /* Task Separator */
        .task-separator {
            display: flex;
            align-items: center;
            margin: var(--space-4) 0;
            gap: var(--space-3);
        }
        
        .separator-line {
            flex: 1;
            height: 1px;
            background: var(--border-light);
        }
        
        .separator-text {
            font-size: 12px;
            color: var(--text-tertiary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Mistral Interface - Right Side */
        .mistral-sidebar {
            width: 400px;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .mistral-header {
            padding: var(--space-6);
            border-bottom: 1px solid var(--border-light);
            background: var(--primary-light);
        }
        
        .mistral-header h2 {
            color: var(--primary);
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 var(--space-2) 0;
        }
        
        .mistral-header p {
            color: var(--text-secondary);
            font-size: 14px;
            margin: 0;
        }
        
        .mistral-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: var(--space-4);
            overflow: hidden;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: var(--space-4);
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-light);
        }
        
        .message {
            margin-bottom: var(--space-3);
            padding: var(--space-3);
            border-radius: var(--radius-md);
            max-width: 80%;
        }
        
        .message.user {
            background: var(--primary-light);
            margin-left: auto;
            border: 1px solid var(--primary);
        }
        
        .message.assistant {
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
        }
        
        .message-text {
            font-size: 14px;
            line-height: 1.4;
            margin: 0;
        }
        
        .message-time {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-top: var(--space-1);
        }
        
        .chat-input-container {
            display: flex;
            gap: var(--space-2);
            flex-shrink: 0;
            padding: var(--space-2);
            background: var(--bg-primary);
            border-top: 1px solid var(--border-light);
        }
        
        .chat-input {
            flex: 1;
            padding: var(--space-3);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            font-size: 14px;
            font-family: inherit;
            resize: none;
            min-height: 40px;
            max-height: 120px;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .send-btn {
            padding: var(--space-3) var(--space-4);
            background: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .send-btn:hover {
            background: var(--primary-hover);
        }
        
        .send-btn:disabled {
            background: var(--text-disabled);
            cursor: not-allowed;
        }
        
        
        /* Loading */
        .loading {
            color: var(--text-tertiary);
            font-size: 14px;
            padding: var(--space-4);
        }
        
        /* Inline-Editing Styles */
        .task-title-edit {
            background: var(--background);
            border: 2px solid var(--primary);
            border-radius: var(--radius-sm);
            padding: 4px 8px;
            font-size: 14px;
            font-family: inherit;
            color: var(--text-primary);
            width: 100%;
            max-width: 300px;
            flex: 1;
            min-width: 0; /* Allows input to shrink */
            overflow: hidden; /* Prevents content from overflowing */
        }

        .task-title-edit:focus {
            outline: none;
            border-color: var(--primary-dark);
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        .priority-badge:hover {
            cursor: pointer;
            opacity: 0.8;
            transform: scale(1.05);
            transition: all 0.2s ease;
        }

        .task-stats span:hover {
            cursor: pointer;
            opacity: 0.8;
            transform: scale(1.05);
            transition: all 0.2s ease;
        }

        /* Task Stats - Only Category */
        .task-stats {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            flex-shrink: 0; /* Prevents task stats from shrinking */
            white-space: nowrap; /* Prevents text wrapping */
        }


        .category-buttons {
            display: flex;
            gap: var(--space-1);
        }

        /* Button Styles */
        .btn {
            padding: var(--space-3) var(--space-4);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-lg);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-1);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: var(--text-primary);
            border-color: var(--border-medium);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: var(--text-primary);
            border-color: var(--border-medium);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: var(--secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-danger {
            background: var(--highlight);
            color: white;
            border: 1px solid var(--highlight);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--background);
            border-radius: var(--radius-lg);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-4);
            border-bottom: 1px solid var(--border-light);
        }

        .modal-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 18px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
        }

        .modal-close:hover {
            background: var(--secondary-light);
            color: var(--text-primary);
        }

        .modal-body {
            padding: var(--space-4);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-2);
            padding: var(--space-4);
            border-top: 1px solid var(--border-light);
        }

        /* Form Styles for Modals */
        .form-group {
            margin-bottom: var(--space-3);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--space-1);
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: var(--space-2);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 14px;
            background: var(--background);
            color: var(--text-primary);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        /* Category Management Styles */
        .category-list {
            margin-bottom: var(--space-4);
        }

        .category-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-2);
            background: var(--secondary-light);
            border-radius: var(--radius-sm);
            margin-bottom: var(--space-2);
        }

        .category-item:hover {
            background: var(--primary-light);
        }

        .category-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .category-actions {
            display: flex;
            gap: var(--space-2);
            align-items: end;
        }

        .category-actions .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        .category-actions button {
            height: fit-content;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .mistral-sidebar {
                width: 100%;
                border-left: none;
                border-top: 1px solid var(--border-light);
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Smart Task Dashboard - Left Side -->
        <div class="smart-dashboard">
            <div class="header">
                <div class="header-left">
                    <h1>üéØ Smart Task Dashboard</h1>
                    <p>Intelligente Task-Verwaltung mit AI-Unterst√ºtzung</p>
                </div>
                <div class="header-right">
                    <button class="btn btn-primary" onclick="openTaskCreationModal()" title="Neuen Task erstellen">
                        ‚ûï Neuer Task
                    </button>
                    <button class="btn btn-secondary" onclick="openCategoryManagementModal()" title="Kategorien verwalten">
                        üìÅ Kategorien
                    </button>
                </div>
                <div class="header-right">
                    <div class="current-date" id="currentDate">Lade Datum...</div>
                </div>
            </div>
            
            <!-- Filter & Sortierung Bar -->
            <div class="filter-sort-bar">
                <div class="filter-section">
                    <button class="filter-btn active" onclick="filterTasks('heute')">Heute</button>
                    <button class="filter-btn" onclick="filterTasks('woche')">Diese Woche</button>
                    <button class="filter-btn" onclick="filterTasks('all')">Alle</button>
                </div>
                <div class="sort-section">
                    <button class="sort-btn active" onclick="setSorting('priority')">Nach Priorit√§t</button>
                    <button class="sort-btn" onclick="setSorting('category')">Nach Kategorie</button>
                </div>
            </div>
            
            <!-- Task Content -->
            <!-- Task Creation Modal -->
            <div class="modal-overlay" id="taskCreationModal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üìù Neuen Task erstellen</h3>
                        <button class="modal-close" onclick="closeTaskCreationModal()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <form id="taskForm">
                            <div class="form-group">
                                <label for="taskTitle">Titel:</label>
                                <input type="text" id="taskTitle" name="title" required>
                            </div>
                            <div class="form-group">
                                <label for="taskCategory">Kategorie:</label>
                                <select id="taskCategory" name="category">
                                    <option value="General">General</option>
                                    <option value="Marketing">Marketing</option>
                                    <option value="Development">Development</option>
                                    <option value="Business">Business</option>
                                    <option value="Personal">Personal</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="taskPriority">Priorit√§t:</label>
                                <select id="taskPriority" name="priority">
                                    <option value="low">Niedrig</option>
                                    <option value="medium" selected>Mittel</option>
                                    <option value="high">Hoch</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="taskDueDate">F√§lligkeitsdatum:</label>
                                <input type="date" id="taskDueDate" name="dueDate">
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" onclick="closeTaskCreationModal()">Abbrechen</button>
                        <button type="button" class="btn btn-primary" onclick="submitTaskForm()">Task erstellen</button>
                    </div>
                </div>
            </div>

            <!-- Category Management Modal -->
            <div class="modal-overlay" id="categoryManagementModal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üìÅ Kategorien verwalten</h3>
                        <button class="modal-close" onclick="closeCategoryManagementModal()">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div class="category-list" id="categoryList">
                            <!-- Categories will be loaded here -->
                        </div>
                        <div class="category-actions">
                            <div class="form-group">
                                <label for="newCategoryName">Neue Kategorie:</label>
                                <input type="text" id="newCategoryName" placeholder="Kategorie-Name eingeben">
                                <button class="btn btn-primary" onclick="createCategory()">Erstellen</button>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" onclick="closeCategoryManagementModal()">Schlie√üen</button>
                    </div>
                </div>
            </div>

            <div id="smartTasks">
                <div class="loading">Lade Tasks...</div>
            </div>
        </div>
        
        <!-- Mistral Interface - Right Side -->
        <div class="mistral-sidebar">
            <div class="mistral-header">
                <h2>ü§ñ Mistral AI Assistant</h2>
                <p>Intelligente Unterst√ºtzung f√ºr Ihre Tasks</p>
            </div>
            
            <div class="mistral-chat">
                
                <!-- Chat Messages -->
                <div class="chat-messages" id="chatMessages">
                    <div class="message assistant">
                        <div class="message-text">Hallo! Ich bin Ihr AI-Assistent f√ºr Task-Management. Wie kann ich Ihnen heute helfen?</div>
                        <div class="message-time">Jetzt</div>
                    </div>
                </div>
                
                <!-- Chat Input -->
                <div class="chat-input-container">
                    <textarea 
                        class="chat-input" 
                        id="chatInput" 
                        placeholder="Fragen Sie Mistral nach Hilfe bei Ihren Tasks..."
                        rows="2"
                    ></textarea>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()">Senden</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allTasks = [];
        let filteredTasks = [];
        let currentFilter = 'heute';
        let currentSorting = 'priority'; // 'priority' oder 'category'
        
        // Get default sorting for current filter
        function getDefaultSorting(filter) {
            if (filter === 'heute' || filter === 'woche') {
                return 'category';
            }
            return 'priority';
        }

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Pr√ºfe und aktualisiere Datum automatisch
            dateSync.checkAndUpdateDate();
            
            loadTasks();
            setupEventListeners();
            updateCurrentDate();
            
            // Lade gespeicherten Tab
            loadSavedTab();
            
            // H√∂re auf Datums√§nderungen
            window.addEventListener('dateChanged', function(event) {
                updateCurrentDate();
                // Lade Tasks neu wenn sich das Datum ge√§ndert hat
                loadTasks();
            });
        });
        
        // Update current date display
        function updateCurrentDate() {
            const currentDateElement = document.getElementById('currentDate');
            if (currentDateElement) {
                const today = dateSync.getCurrentDate();
                const dayName = dateSync.formatDayOfWeek(today.getDay());
                const dayNumber = today.getDate();
                const monthName = dateSync.formatMonth(today.getMonth());
                const year = today.getFullYear();
                
                currentDateElement.textContent = `${dayName}, ${dayNumber}. ${monthName} ${year}`;
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            
            chatInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // Auto-resize textarea
            chatInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            });
        }

        // Load tasks from API
        async function loadTasks() {
            try {
                const response = await fetch('http://localhost:3001/api/smart-tasks');
                const data = await response.json();
                allTasks = data.tasks || [];
                filteredTasks = [...allTasks];
                renderTasks();
                updateStats();
            } catch (error) {
                console.error('Fehler beim Laden der Tasks:', error);
                document.getElementById('smartTasks').innerHTML = '<div class="loading">Fehler beim Laden der Tasks</div>';
            }
        }

        // Filter tasks
        function filterTasks(filter) {
            currentFilter = filter;
            
            // Set default sorting for this filter
            currentSorting = getDefaultSorting(filter);
            
            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update sort button states
            document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
            const activeSortBtn = document.querySelector(`.sort-btn[onclick*="${currentSorting}"]`);
            if (activeSortBtn) {
                activeSortBtn.classList.add('active');
            }
            
            // Speichere aktiven Tab
            saveActiveTab(filter);
            
            switch (filter) {
                case 'all':
                    filteredTasks = [...allTasks];
                    renderMarkdownStructure();
                    break;
                case 'heute':
                    filteredTasks = getTodayTasks();
                    renderTodayView();
                    break;
                case 'woche':
                    filteredTasks = getWeekTasks();
                    renderMarkdownStructure();
                    break;
                case 'hoch':
                    filteredTasks = allTasks.filter(task => task.priority === 'high');
                    renderTasks();
                    break;
                case '√ºberf√§llig':
                    filteredTasks = allTasks.filter(task => task.deadline_status === 'overdue');
                    renderTasks();
                    break;
            }
            
            updateStats();
        }

        // Set sorting method
        function setSorting(sorting) {
            currentSorting = sorting;
            
            // Update button states
            document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Re-render current view with new sorting
            switch (currentFilter) {
                case 'all':
                    filteredTasks = [...allTasks];
                    renderTasks();
                    break;
                case 'heute':
                    filteredTasks = getTodayTasks();
                    renderTodayView();
                    break;
                case 'woche':
                    filteredTasks = getWeekTasks();
                    renderMarkdownStructure();
                    break;
                case 'hoch':
                    filteredTasks = allTasks.filter(task => task.priority === 'high');
                    renderTasks();
                    break;
                case '√ºberf√§llig':
                    filteredTasks = allTasks.filter(task => task.deadline_status === 'overdue');
                    renderTasks();
                    break;
            }
        }

        // Get today's tasks - Tasks mit Due Date heute (sowohl offene als auch erledigte)
        function getTodayTasks() {
            const today = dateSync.formatDateForAPI(dateSync.getCurrentDate());
            return allTasks.filter(task => {
                if (!task.due_date) return false;
                return task.due_date === today;
            });
        }

        // Get week's tasks
        function getWeekTasks() {
            const currentWeekStart = dateSync.getCurrentWeekStart();
            const nextWeekStart = dateSync.getNextWeekStart();
            
            return allTasks.filter(task => {
                if (!task.due_date) return false;
                const taskDate = new Date(task.due_date);
                return taskDate >= currentWeekStart && taskDate < nextWeekStart;
            });
        }

        // Render Smart Task Structure View (Dynamic)
        function renderMarkdownStructure() {
            const container = document.getElementById('smartTasks');
            
            // Get current week and next week using DateSync
            const currentWeekStart = dateSync.getCurrentWeekStart();
            const nextWeekStart = dateSync.getNextWeekStart();
            
            // Group tasks by due dates and categories
            const thisWeekTasks = filteredTasks.filter(task => {
                if (!task.due_date) return false;
                const taskDate = new Date(task.due_date);
                return taskDate >= currentWeekStart && taskDate < nextWeekStart;
            });
            
            const nextWeekTasks = filteredTasks.filter(task => {
                if (!task.due_date) return false;
                const taskDate = new Date(task.due_date);
                const nextWeekEnd = new Date(nextWeekStart);
                nextWeekEnd.setDate(nextWeekStart.getDate() + 7);
                return taskDate >= nextWeekStart && taskDate < nextWeekEnd;
            });
            
            const overdueTasks = filteredTasks.filter(task => {
                if (!task.due_date) return false;
                const taskDate = new Date(task.due_date);
                return taskDate < currentWeekStart;
            });
            
            const noDateTasks = filteredTasks.filter(task => !task.due_date);
            
            // Get later tasks (beyond next week)
            const laterTasks = filteredTasks.filter(task => {
                if (!task.due_date) return false;
                const taskDate = new Date(task.due_date);
                const nextWeekEnd = new Date(nextWeekStart);
                nextWeekEnd.setDate(nextWeekStart.getDate() + 7);
                return taskDate >= nextWeekEnd;
            });
            
            // Group later tasks by month
            const tasksByMonth = {};
            laterTasks.forEach(task => {
                const taskDate = new Date(task.due_date);
                const monthKey = `${taskDate.getFullYear()}-${String(taskDate.getMonth() + 1).padStart(2, '0')}`;
                const monthName = dateSync.formatMonth(taskDate.getMonth());
                const year = taskDate.getFullYear();
                const displayKey = `${monthName} ${year}`;
                
                if (!tasksByMonth[displayKey]) {
                    tasksByMonth[displayKey] = [];
                }
                tasksByMonth[displayKey].push(task);
            });
            
            // Get week days from DateSync
            const weekDays = dateSync.getWeekDays();
            
            container.innerHTML = `
                <div class="smart-structure-view">
                    
                    ${overdueTasks.length > 0 ? `
                        <h2 style="color: var(--highlight); font-size: 20px; font-weight: 500; margin: var(--space-6) 0 var(--space-3) 0;">‚ö†Ô∏è √úberf√§llige Tasks</h2>
                        ${renderTaskGroup(overdueTasks)}
                    ` : ''}
                    
                    <h2 style="color: var(--text-primary); font-size: 20px; font-weight: 500; margin: var(--space-6) 0 var(--space-3) 0;">üìÖ Diese Woche (${dateSync.getCurrentWeekRange()})</h2>
                    
                    ${weekDays.map(day => {
                        const tasks = thisWeekTasks.filter(task => task.due_date === day.apiFormat);
                        if (tasks.length === 0) return '';
                        
                        return `
                            <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 500; margin: var(--space-4) 0 var(--space-2) 0;">${day.dayName}, ${day.dayNumber}. ${day.monthName}</h3>
                            ${renderTaskGroup(tasks)}
                        `;
                    }).join('')}
                    
                    ${nextWeekTasks.length > 0 ? `
                        <h2 style="color: var(--text-primary); font-size: 20px; font-weight: 500; margin: var(--space-6) 0 var(--space-3) 0;">üìÖ N√§chste Woche (${dateSync.getNextWeekRange()})</h2>
                        ${renderTaskGroup(nextWeekTasks)}
                    ` : ''}
                    
                    ${Object.keys(tasksByMonth).length > 0 ? `
                        <h2 style="color: var(--text-primary); font-size: 20px; font-weight: 500; margin: var(--space-6) 0 var(--space-3) 0;">üìÖ Sp√§tere Termine</h2>
                        ${Object.keys(tasksByMonth).sort().map(month => `
                            <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 500; margin: var(--space-4) 0 var(--space-2) 0;">üìÖ ${month}</h3>
                            ${renderTaskGroup(tasksByMonth[month])}
                        `).join('')}
                    ` : ''}
                    
                    ${noDateTasks.length > 0 ? `
                        <h2 style="color: var(--text-primary); font-size: 20px; font-weight: 500; margin: var(--space-6) 0 var(--space-3) 0;">üìã Tasks ohne Datum</h2>
                        ${renderTaskGroup(noDateTasks)}
                    ` : ''}
                </div>
            `;
        }

        // Render today's view with dynamic sections
        function renderTodayView() {
            const container = document.getElementById('smartTasks');
            
            if (currentSorting === 'priority') {
                // Group tasks by priority
                const highPriorityTasks = filteredTasks.filter(task => task.priority === 'high' || task.deadline_status === 'overdue');
                const mediumPriorityTasks = filteredTasks.filter(task => task.priority === 'medium' && task.deadline_status !== 'overdue');
                const lowPriorityTasks = filteredTasks.filter(task => task.priority === 'low');
                
                container.innerHTML = `
                    
                    ${highPriorityTasks.length > 0 ? `
                        <div style="margin-bottom: var(--space-6);">
                            <h3 style="color: var(--highlight); margin-bottom: var(--space-4); display: flex; align-items: center; gap: var(--space-2);">
                                üî• HOCHPRIORIT√ÑT (${highPriorityTasks.length} Tasks)
                            </h3>
                            ${renderTaskGroup(highPriorityTasks)}
                        </div>
                    ` : ''}
                    
                    ${mediumPriorityTasks.length > 0 ? `
                        <div style="margin-bottom: var(--space-6);">
                            <h3 style="color: var(--text-primary); margin-bottom: var(--space-4); display: flex; align-items: center; gap: var(--space-2);">
                                ‚ö° MITTELPRIORIT√ÑT (${mediumPriorityTasks.length} Tasks)
                            </h3>
                            ${renderTaskGroup(mediumPriorityTasks)}
                        </div>
                    ` : ''}
                    
                    ${lowPriorityTasks.length > 0 ? `
                        <div style="margin-bottom: var(--space-6);">
                            <h3 style="color: var(--text-primary); margin-bottom: var(--space-4); display: flex; align-items: center; gap: var(--space-2);">
                                üìù NIEDRIGPRIORIT√ÑT (${lowPriorityTasks.length} Tasks)
                            </h3>
                            ${renderTaskGroup(lowPriorityTasks)}
                        </div>
                    ` : ''}
                    
                    <div style="background: var(--primary-light); border-radius: var(--radius-lg); padding: var(--space-4); margin-top: var(--space-6); border: 1px solid var(--primary);">
                        <h4 style="color: var(--primary); margin: 0 0 var(--space-2) 0;">üí° Heute-Fokus</h4>
                        <p style="margin: 0; font-size: 14px; color: var(--text-secondary);">
                            Konzentrieren Sie sich zuerst auf die <strong>Hochpriorit√§t</strong> Tasks. 
                            ${highPriorityTasks.length > 0 ? `Sie haben ${highPriorityTasks.length} √ºberf√§llige oder hochpriorit√§re Tasks.` : 'Alle Hochpriorit√§t-Tasks sind erledigt!'}
                        </p>
                    </div>
                `;
            } else {
                // Bei Kategorie-Sortierung: Einfach alle Tasks rendern ohne Priorit√§ts-√úberschriften
                container.innerHTML = `
                    
                    ${renderTaskGroup(filteredTasks)}
                `;
            }
        }

        // Render a group of tasks with dynamic sorting
        function renderTaskGroup(tasks) {
            if (tasks.length === 0) return '';
            
            if (currentSorting === 'priority') {
                return renderByPriority(tasks);
            } else {
                return renderByCategory(tasks);
            }
        }
        
        // Render tasks grouped by priority (category as label)
        function renderByPriority(tasks) {
            // Sort by priority first, then by status
            const sortedTasks = [...tasks].sort((a, b) => {
                // First: pending vs completed
                if (a.status === 'completed' && b.status !== 'completed') return 1;
                if (a.status !== 'completed' && b.status === 'completed') return -1;
                
                // Second: priority order
                const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                const aPriority = priorityOrder[a.priority] || 2;
                const bPriority = priorityOrder[b.priority] || 2;
                
                if (aPriority !== bPriority) return bPriority - aPriority;
                
                // Third: deadline status
                const deadlineOrder = { 'overdue': 4, 'due_today': 3, 'due_tomorrow': 2, 'due_soon': 1, 'due_this_week': 1, 'due_later': 0, 'no_deadline': 0 };
                const aDeadline = deadlineOrder[a.deadline_status] || 0;
                const bDeadline = deadlineOrder[b.deadline_status] || 0;
                
                return bDeadline - aDeadline;
            });
            
            // Separate pending and completed tasks
            const pendingTasks = sortedTasks.filter(task => task.status !== 'completed');
            const completedTasks = sortedTasks.filter(task => task.status === 'completed');
            
            let html = '';
            
            // Render pending tasks first with drop zone
            if (pendingTasks.length > 0) {
                html += `
                    <div class="category-drop-zone" 
                         ondrop="dropOnCategory(event, 'General')" 
                         ondragover="event.preventDefault(); event.dataTransfer.dropEffect = 'move';"
                         ondragenter="event.preventDefault(); event.target.style.background='var(--primary-light)';"
                         ondragleave="event.target.style.background='transparent';">
                        ${pendingTasks.map(task => renderSingleTask(task)).join('')}
                    </div>
                `;
            }
            
            // Add separator if there are both pending and completed tasks
            if (pendingTasks.length > 0 && completedTasks.length > 0) {
                html += '<div class="task-separator"><div class="separator-line"></div><span class="separator-text">Erledigte Tasks</span><div class="separator-line"></div></div>';
            }
            
            // Render completed tasks last with drop zone
            if (completedTasks.length > 0) {
                html += `
                    <div class="category-drop-zone" 
                         ondrop="dropOnCategory(event, 'General')" 
                         ondragover="event.preventDefault(); event.dataTransfer.dropEffect = 'move';"
                         ondragenter="event.preventDefault(); event.target.style.background='var(--primary-light)';"
                         ondragleave="event.target.style.background='transparent';">
                        ${completedTasks.map(task => renderSingleTask(task)).join('')}
                    </div>
                `;
            }
            
            return html;
        }
        
        // Render tasks grouped by category (priority as label)
        function renderByCategory(tasks) {
            // Gruppiere Tasks nach Kategorien
            const tasksByCategory = {};
            tasks.forEach(task => {
                const category = task.category || 'General';
                if (!tasksByCategory[category]) {
                    tasksByCategory[category] = [];
                }
                tasksByCategory[category].push(task);
            });
            
            // Sortiere Kategorien nach Anzahl der Tasks (gr√∂√üte zuerst)
            // Filtere "General" Kategorien heraus, wenn alle Tasks erledigt sind
            const sortedCategories = Object.entries(tasksByCategory)
                .filter(([category, categoryTasks]) => {
                    if (category === 'General') {
                        // Zeige "General" nur wenn es noch offene Tasks gibt
                        return categoryTasks.some(task => task.status !== 'completed');
                    }
                    return true;
                })
                .sort(([,a], [,b]) => b.length - a.length);
            
            // Sammle alle erledigten Tasks (auch aus "General")
            let allCompletedTasks = [];
            Object.entries(tasksByCategory).forEach(([category, categoryTasks]) => {
                const completedTasks = categoryTasks.filter(task => task.status === 'completed');
                allCompletedTasks = allCompletedTasks.concat(completedTasks);
            });
            
            const categoryIcons = {
                'Business': 'üíº',
                'Development': 'üíª',
                'Marketing': 'üì¢',
                'PUSH': 'üöÄ',
                'Personal': 'üë§',
                'General': 'üìã',
                'Check24': 'üè¢',
                'Sustain': 'üå±',
                'Meetings': 'ü§ù',
                'Unbekannt': '‚ùì'
            };
            
            let html = '';
            
            sortedCategories.forEach(([category, categoryTasks]) => {
                const icon = categoryIcons[category] || 'üìÅ';
                
                // Sort tasks by priority first, then by status
                const sortedTasks = [...categoryTasks].sort((a, b) => {
                    // First: pending vs completed
                    if (a.status === 'completed' && b.status !== 'completed') return 1;
                    if (a.status !== 'completed' && b.status === 'completed') return -1;
                    
                    // Second: priority order
                    const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                    const aPriority = priorityOrder[a.priority] || 2;
                    const bPriority = priorityOrder[b.priority] || 2;
                    
                    if (aPriority !== bPriority) return bPriority - aPriority;
                    
                    return 0;
                });
                
                // Separate pending and completed tasks
                const pendingTasks = sortedTasks.filter(task => task.status !== 'completed');
                const completedTasks = sortedTasks.filter(task => task.status === 'completed');
                
                // Sammle erledigte Tasks f√ºr sp√§ter (aber nicht aus "General" wenn alle erledigt)
                if (!(category === 'General' && completedTasks.length === categoryTasks.length)) {
                    allCompletedTasks = allCompletedTasks.concat(completedTasks);
                }
                
                // Nur Kategorie-Header anzeigen wenn mehr als 1 Task oder wenn es nicht "General" ist
                if (categoryTasks.length > 1 || category !== 'General') {
                    html += `
                        <div style="margin: var(--space-3) 0 var(--space-2) 0; padding: var(--space-2) var(--space-3); background: var(--secondary-light); border-radius: var(--radius-md); border-left: 3px solid var(--primary);"
                             ondrop="dropOnCategory(event, '${category}')" 
                             ondragover="event.preventDefault(); event.dataTransfer.dropEffect = 'move';"
                             ondragenter="event.preventDefault(); event.target.style.background='var(--primary-light)';"
                             ondragleave="event.target.style.background='var(--secondary-light)';">
                            <span style="font-size: 12px; font-weight: 600; color: var(--text-primary);">
                                ${icon} ${category} (${categoryTasks.length})
                            </span>
                        </div>
                    `;
                }
                
                // Render nur pending tasks hier mit Drop-Zone
                if (pendingTasks.length > 0) {
                    html += `
                        <div class="category-drop-zone" 
                             ondrop="dropOnCategory(event, '${category}')" 
                             ondragover="event.preventDefault(); event.dataTransfer.dropEffect = 'move';"
                             ondragenter="event.preventDefault(); event.target.style.background='var(--primary-light)';"
                             ondragleave="event.target.style.background='transparent';">
                            ${pendingTasks.map(task => renderSingleTask(task)).join('')}
                        </div>
                    `;
                }
            });
            
            // Alle erledigten Tasks ganz nach unten ohne Kategorie-Header
            if (allCompletedTasks.length > 0) {
                html += '<div class="task-separator"><div class="separator-line"></div><span class="separator-text">Erledigte Tasks</span><div class="separator-line"></div></div>';
                html += `
                    <div class="category-drop-zone" 
                         ondrop="dropOnCategory(event, 'General')" 
                         ondragover="event.preventDefault(); event.dataTransfer.dropEffect = 'move';"
                         ondragenter="event.preventDefault(); event.target.style.background='var(--primary-light)';"
                         ondragleave="event.target.style.background='transparent';">
                        ${allCompletedTasks.map(task => renderSingleTask(task)).join('')}
                    </div>
                `;
            }
            
            return html;
        }
        
        // Render a single task
        function renderSingleTask(task) {
            const hierarchyClass = task.hierarchy_level ? `hierarchy-level-${task.hierarchy_level}` : '';
            const completedClass = task.status === 'completed' ? 'completed-task' : '';
            
            // Remove markdown formatting (**) and category symbols from task titles
            const cleanTitle = task.title.replace(/\*\*/g, '').replace(/\s*üìÅ\s*[^-\s]+/g, '').trim();
            
            // Bei Kategorie-Sortierung: Priorit√§t-Badge nur anzeigen wenn nicht "medium"
            const showPriorityBadge = currentSorting === 'priority' || task.priority !== 'medium';
            
            return `
                <div class="smart-task-card ${task.priority}-priority ${task.deadline_status && task.deadline_status !== null ? task.deadline_status.replace('_', '-') : 'no-deadline'} ${hierarchyClass} ${completedClass}" 
                     draggable="true" 
                     ondragstart="dragStart(event, '${task.id}')" 
                     ondragend="dragEnd(event)">
                    <div class="task-content">
                        <div class="task-title">
                            <span class="task-checkbox" onclick="event.stopPropagation(); toggleTask('${task.id}')">
                                ${task.status === 'completed' ? '‚úÖ' : '‚òê'}
                            </span>
                            <div class="task-title-editable" onclick="event.stopPropagation(); startEditTitle('${task.id}', '${cleanTitle.replace(/'/g, "\\'")}')">
                                <span class="task-title-text">${cleanTitle}</span>
                                <span class="edit-hint">‚úèÔ∏è</span>
                            </div>
                            <input type="text" class="task-title-edit" style="display: none;" onblur="saveEditTitle('${task.id}')" onkeypress="handleEditKeypress(event, '${task.id}')" />
                        </div>
                    </div>
                    <div class="task-meta">
                        ${showPriorityBadge ? `
                            <div class="priority-editable" onclick="event.stopPropagation(); showPriorityMenu('${task.id}', '${task.priority}', event)">
                                <span class="priority-badge priority-${task.priority}">${task.priority}</span>
                                <span class="edit-hint">‚öôÔ∏è</span>
                            </div>
                        ` : ''}
                        ${task.deadline_status && task.deadline_status !== null && task.deadline_status !== 'no_deadline' && task.deadline_status !== 'due_today' ? `<span class="deadline-badge deadline-${task.deadline_status.replace('_', '-')}">${getDeadlineText(task.deadline_status)}</span>` : ''}
                        <button class="delete-task-btn" onclick="event.stopPropagation(); deleteTask('${task.id}')" title="Task l√∂schen">üóëÔ∏è</button>
                    </div>
                    ${task.due_date ? `
                        ${(() => {
                            const dueDate = new Date(task.due_date);
                            const today = dateSync.getCurrentDate();
                            const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                            
                            // Bei "Heute" Filterung: Kein Datums-Label f√ºr heute f√§llige Tasks
                            if (currentFilter === 'heute' && diffDays === 0) return '';
                            
                            return `
                                <div class="due-date-editable" onclick="event.stopPropagation(); showDateMenu('${task.id}', '${task.due_date}', event)">
                                    <div class="due-date-display">
                                        üìÖ ${dateSync.formatDateForDisplay(new Date(task.due_date))}
                                        ${(() => {
                                            // Nur zus√§tzliche Info anzeigen, wenn es nicht "heute" ist
                                            if (diffDays === 0) return ''; // Keine zus√§tzliche Info f√ºr heute
                                            if (diffDays === 1) return '<span style="color: var(--primary); font-weight: 500;">(Morgen)</span>';
                                            if (diffDays === -1) return '<span style="color: var(--highlight); font-weight: 600;">(Gestern)</span>';
                                            if (diffDays < 0) return `<span style="color: var(--highlight); font-weight: 600;">(vor ${Math.abs(diffDays)} Tagen)</span>`;
                                            return `<span style="color: var(--text-secondary);">(in ${diffDays} Tagen)</span>`;
                                        })()}
                                    </div>
                                    <span class="edit-hint">üìÖ</span>
                                </div>
                            `;
                        })()}
                    ` : ''}
                    <div class="task-stats">
                        <div class="category-editable" onclick="event.stopPropagation(); showCategoryMenu('${task.id}', '${task.category}', event)">
                            <span>üìÅ ${task.category}</span>
                            <span class="edit-hint">‚öôÔ∏è</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Render tasks (fallback)
        function renderTasks() {
            const container = document.getElementById('smartTasks');
            container.innerHTML = renderTaskGroup(filteredTasks);
        }


        // Update statistics
        function updateStats() {
            // Stats wurden entfernt - Funktion bleibt f√ºr Kompatibilit√§t
        }

        // Get deadline text
        function getDeadlineText(status) {
            const statusMap = {
                'overdue': '√úberf√§llig',
                'due_today': 'Heute',
                'due_tomorrow': 'Morgen',
                'due_soon': 'Bald',
                'due_this_week': 'Diese Woche',
                'due_later': 'Sp√§ter',
                'no_deadline': 'Kein Datum'
            };
            return statusMap[status] || status;
        }

        // Drag & Drop Functions
        let draggedTaskId = null;
        
        function dragStart(event, taskId) {
            draggedTaskId = taskId;
            event.dataTransfer.effectAllowed = 'move';
            event.target.style.opacity = '0.5';
        }
        
        function dragEnd(event) {
            event.target.style.opacity = '';
            draggedTaskId = null;
        }
        
        function dragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        
        function dropOnCategory(event, categoryName) {
            event.preventDefault();
            event.stopPropagation();
            
            // Reset drop zone styling
            event.target.style.background = 'var(--secondary-light)';
            
            if (draggedTaskId) {
                const task = allTasks.find(t => t.id === draggedTaskId);
                if (task && task.category !== categoryName) {
                    console.log(`Moving task ${task.title} to category ${categoryName}`);
                    
                    // Update task category
                    task.category = categoryName;
                    task.updated_at = new Date().toISOString();
                    
                    // Send update to API using the universal updateTask function
                    updateTask(task.id, { category: categoryName });
                    
                    // Re-render current view
                    switch (currentFilter) {
                        case 'all':
                            filteredTasks = [...allTasks];
                            renderTasks();
                            break;
                        case 'heute':
                            filteredTasks = getTodayTasks();
                            renderTodayView();
                            break;
                        case 'woche':
                            filteredTasks = getWeekTasks();
                            renderMarkdownStructure();
                            break;
                        case 'hoch':
                            filteredTasks = allTasks.filter(task => task.priority === 'high');
                            renderTasks();
                            break;
                        case '√ºberf√§llig':
                            filteredTasks = allTasks.filter(task => task.deadline_status === 'overdue');
                            renderTasks();
                            break;
                    }
                    
                    updateStats();
                }
            }
            
            draggedTaskId = null;
        }
        
        // Update task category in database

        // Toggle task completion
        async function toggleTask(taskId) {
            const task = allTasks.find(t => t.id === taskId);
            if (task) {
                const newStatus = task.status === 'completed' ? 'pending' : 'completed';
                
                try {
                    // Update task in database
                    const response = await fetch(`http://localhost:3001/api/tasks/${taskId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            status: newStatus,
                            updated_at: new Date().toISOString()
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        // Update local task
                        task.status = newStatus;
                        task.updated_at = new Date().toISOString();
                        
                        // Update display
                        renderTasks();
                        updateStats();
                        
                        console.log(`‚úÖ Task ${taskId} toggled to ${newStatus}`);
                    } else {
                        console.error('Failed to update task:', data.error);
                    }
                } catch (error) {
                    console.error('Error updating task:', error);
                }
            }
        }

        // Delete task
        async function deleteTask(taskId) {
            try {
                const response = await fetch(`http://localhost:3001/api/tasks/${taskId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    // Remove task from local array
                    allTasks = allTasks.filter(t => t.id !== taskId);
                    
                    // Update display
                    renderTasks();
                    updateStats();
                    
                    console.log(`‚úÖ Task ${taskId} deleted`);
                } else {
                    console.error('Failed to delete task:', data.error);
                    alert('Fehler beim L√∂schen des Tasks: ' + data.error);
                }
            } catch (error) {
                console.error('Error deleting task:', error);
                alert('Fehler beim L√∂schen des Tasks: ' + error.message);
            }
        }

        // Parse Mistral Action Responses
        async function parseMistralAction(response) {
            try {
                // Try to parse as JSON first
                const jsonResponse = JSON.parse(response);
                if (jsonResponse.command && jsonResponse.reply) {
                    // Parse action command from JSON
                    const actionMatch = jsonResponse.command.match(/ACTION:(\w+)\|(.+)/);
                    if (!actionMatch) {
                        return { executed: false };
                    }
                    
                    const action = actionMatch[1];
                    const params = actionMatch[2];
                    
                    // Parse parameters
                    const paramObj = {};
                    params.split('|').forEach(param => {
                        const [key, value] = param.split(':');
                        if (key && value) {
                            paramObj[key] = value;
                        }
                    });
                    
                    // Execute action based on type
                    let result = { executed: false };
                    switch (action) {
                        case 'CREATE_TASK':
                            result = await executeCreateTask(paramObj);
                            break;
                        case 'DELETE_CATEGORY':
                            result = await executeDeleteCategory(paramObj);
                            break;
                        case 'MOVE_TASKS':
                            result = await executeMoveTasks(paramObj);
                            break;
                        case 'CREATE_MULTIPLE':
                            result = await executeCreateMultiple(paramObj);
                            break;
                        case 'QUERY_TASKS':
                            result = await executeQueryTasks(paramObj);
                            break;
                        default:
                            return { executed: false };
                    }
                    
                    // Use the user-friendly reply from JSON if action was executed
                    if (result.executed) {
                        result.message = jsonResponse.reply;
                    }
                    
                    return result;
                }
            } catch (jsonError) {
                // Fallback: try to parse as old ACTION: format
                if (!response.includes('ACTION:')) {
                    return { executed: false };
                }
                
                // Parse action command
                const actionMatch = response.match(/ACTION:(\w+)\|(.+)/);
                if (!actionMatch) {
                    return { executed: false };
                }
                
                const action = actionMatch[1];
                const params = actionMatch[2];
                
                // Parse parameters
                const paramObj = {};
                params.split('|').forEach(param => {
                    const [key, value] = param.split(':');
                    if (key && value) {
                        paramObj[key] = value;
                    }
                });
                
                // Execute action based on type
                switch (action) {
                    case 'CREATE_TASK':
                        return await executeCreateTask(paramObj);
                    case 'DELETE_CATEGORY':
                        return await executeDeleteCategory(paramObj);
                    case 'MOVE_TASKS':
                        return await executeMoveTasks(paramObj);
                    case 'CREATE_MULTIPLE':
                        return await executeCreateMultiple(paramObj);
                    case 'QUERY_TASKS':
                        return await executeQueryTasks(paramObj);
                    default:
                        return { executed: false };
                }
            }
        }

        // Action Executors
        async function executeCreateTask(params) {
            try {
                const response = await fetch('http://localhost:3001/api/tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: params.TITLE || 'Neuer Task',
                        category: params.CATEGORY || 'General',
                        status: 'pending',
                        priority: 'medium',
                        due_date: params.DUE_DATE || '2025-10-07'
                    })
                });
                
                if (response.ok) {
                    const dueDate = params.DUE_DATE ? ` f√ºr ${params.DUE_DATE}` : '';
                    return {
                        executed: true,
                        message: `‚úÖ Task "${params.TITLE}" in der Kategorie "${params.CATEGORY}"${dueDate} erstellt.`
                    };
                } else {
                    return {
                        executed: true,
                        message: `‚ùå Fehler beim Erstellen des Tasks.`
                    };
                }
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Erstellen des Tasks: ${error.message}`
                };
            }
        }

        async function executeDeleteCategory(params) {
            try {
                const tasksToDelete = allTasks.filter(task => 
                    task.category.toLowerCase() === params.CATEGORY.toLowerCase() && 
                    task.status !== 'completed'
                );
                
                if (tasksToDelete.length === 0) {
                    return {
                        executed: true,
                        message: `Keine offenen Tasks in der Kategorie "${params.CATEGORY}" gefunden.`
                    };
                }
                
                let deletedCount = 0;
                for (const task of tasksToDelete) {
                    const response = await fetch(`http://localhost:3001/api/tasks/${task.id}`, {
                        method: 'DELETE'
                    });
                    if (response.ok) {
                        deletedCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${deletedCount} Tasks aus der Kategorie "${params.CATEGORY}" gel√∂scht.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim L√∂schen der Tasks: ${error.message}`
                };
            }
        }

        async function executeMoveTasks(params) {
            try {
                const tasksToMove = allTasks.filter(task => 
                    task.category.toLowerCase() === params.CATEGORY.toLowerCase() && 
                    task.status !== 'completed'
                );
                
                if (tasksToMove.length === 0) {
                    return {
                        executed: true,
                        message: `Keine ${params.CATEGORY} Tasks gefunden.`
                    };
                }
                
                let movedCount = 0;
                for (const task of tasksToMove) {
                    const response = await fetch(`http://localhost:3001/api/tasks/${task.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ due_date: params.TO_DATE })
                    });
                    if (response.ok) {
                        movedCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${movedCount} ${params.CATEGORY} Tasks auf ${params.TO_DATE} verschoben.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Verschieben der Tasks: ${error.message}`
                };
            }
        }

        async function executeCreateMultiple(params) {
            try {
                const count = parseInt(params.COUNT) || 1;
                const category = params.CATEGORY || 'General';
                const titles = params.TITLES ? params.TITLES.split(',') : [];
                
                let createdCount = 0;
                for (let i = 0; i < count; i++) {
                    const title = titles[i] || `${category} Task ${i + 1}`;
                    const response = await fetch('http://localhost:3001/api/tasks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title: title.trim(),
                            category: category,
                            status: 'pending',
                            priority: 'medium',
                            due_date: '2025-10-07'
                        })
                    });
                    if (response.ok) {
                        createdCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${createdCount} neue Tasks in der Kategorie "${category}" erstellt.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Erstellen der Tasks: ${error.message}`
                };
            }
        }

        async function executeQueryTasks(params) {
            try {
                let filteredTasks = [...allTasks];
                
                // Apply filters
                if (params.FILTER) {
                    const filters = params.FILTER.split(',');
                    filters.forEach(filter => {
                        const [key, value] = filter.split('=');
                        if (key && value) {
                            switch (key.trim()) {
                                case 'category':
                                    filteredTasks = filteredTasks.filter(task => 
                                        task.category.toLowerCase() === value.toLowerCase()
                                    );
                                    break;
                                case 'date':
                                    filteredTasks = filteredTasks.filter(task => 
                                        task.due_date === value
                                    );
                                    break;
                                case 'status':
                                    filteredTasks = filteredTasks.filter(task => 
                                        task.status === value
                                    );
                                    break;
                                case 'priority':
                                    filteredTasks = filteredTasks.filter(task => 
                                        task.priority === value
                                    );
                                    break;
                            }
                        }
                    });
                }
                
                if (filteredTasks.length === 0) {
                    return {
                        executed: true,
                        message: `Keine Tasks gefunden, die den Kriterien entsprechen.`
                    };
                }
                
                // Format task list for display
                let taskList = '';
                filteredTasks.forEach((task, index) => {
                    const status = task.status === 'completed' ? '‚úÖ' : '‚è≥';
                    const priority = task.priority === 'high' ? 'üî•' : task.priority === 'low' ? 'üåÖ' : '';
                    taskList += `${index + 1}. ${status} ${task.title} ${priority} (${task.category})\n`;
                });
                
                return {
                    executed: true,
                    message: `üìã Ich habe ${filteredTasks.length} Tasks gefunden:\n\n${taskList}\n\nWas m√∂chtest du mit diesen Tasks machen?`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Abfragen der Tasks: ${error.message}`
                };
            }
        }

        // Action Parser for Mistral Commands
        async function parseAndExecuteAction(prompt) {
            const lowerPrompt = prompt.toLowerCase();
            
            // Pattern 1: Delete all tasks of category
            const deleteCategoryMatch = lowerPrompt.match(/l√∂sche?\s+(alle\s+)?(todos?|tasks?)\s+(der\s+)?kategorie\s+(\w+)/i);
            if (deleteCategoryMatch) {
                const category = deleteCategoryMatch[4];
                return await deleteTasksByCategory(category);
            }
            
            // Pattern 2: Move tasks from today to tomorrow
            const moveTasksMatch = lowerPrompt.match(/verschiebe?\s+(die\s+)?(\w+)\s+(todos?|tasks?)\s+(von\s+)?heute\s+(auf\s+)?morgen/i);
            if (moveTasksMatch) {
                const category = moveTasksMatch[2];
                return await moveTasksToTomorrow(category);
            }
            
            // Pattern 3: Create multiple tasks in category
            const createTasksMatch = lowerPrompt.match(/erstelle?\s+(mir\s+)?(folgende\s+)?(\d+)\s+(todos?|tasks?)\s+(in\s+der\s+)?kategorie\s+(\w+)/i);
            if (createTasksMatch) {
                const count = parseInt(createTasksMatch[3]);
                const category = createTasksMatch[6];
                return await createMultipleTasks(count, category, prompt);
            }
            
            // Pattern 4: Move all tasks of category to specific date
            const moveToDateMatch = lowerPrompt.match(/verschiebe?\s+(alle\s+)?(\w+)\s+(todos?|tasks?)\s+(auf\s+)?(\d{1,2}\.\d{1,2}\.?\d{0,4})/i);
            if (moveToDateMatch) {
                const category = moveToDateMatch[2];
                const dateStr = moveToDateMatch[5];
                return await moveTasksToDate(category, dateStr);
            }
            
            return { executed: false };
        }

        // Action Functions
        async function deleteTasksByCategory(category) {
            try {
                const tasksToDelete = allTasks.filter(task => 
                    task.category.toLowerCase() === category.toLowerCase() && 
                    task.status !== 'completed'
                );
                
                if (tasksToDelete.length === 0) {
                    return {
                        executed: true,
                        message: `Keine offenen Tasks in der Kategorie "${category}" gefunden.`
                    };
                }
                
                let deletedCount = 0;
                for (const task of tasksToDelete) {
                    const response = await fetch(`http://localhost:3001/api/tasks/${task.id}`, {
                        method: 'DELETE'
                    });
                    if (response.ok) {
                        deletedCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${deletedCount} Tasks aus der Kategorie "${category}" gel√∂scht.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim L√∂schen der Tasks: ${error.message}`
                };
            }
        }

        async function moveTasksToTomorrow(category) {
            try {
                const tasksToMove = allTasks.filter(task => 
                    task.category.toLowerCase() === category.toLowerCase() && 
                    task.status !== 'completed' &&
                    task.due_date === '2025-10-07' // Today
                );
                
                if (tasksToMove.length === 0) {
                    return {
                        executed: true,
                        message: `Keine ${category} Tasks f√ºr heute gefunden.`
                    };
                }
                
                let movedCount = 0;
                for (const task of tasksToMove) {
                    const response = await fetch(`http://localhost:3001/api/tasks/${task.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ due_date: '2025-10-08' })
                    });
                    if (response.ok) {
                        movedCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${movedCount} ${category} Tasks von heute auf morgen verschoben.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Verschieben der Tasks: ${error.message}`
                };
            }
        }

        async function createMultipleTasks(count, category, originalPrompt) {
            try {
                // Extract task titles from the prompt
                const lines = originalPrompt.split('\n');
                const taskTitles = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.match(/^\d+\.\s*(.+)$/)) {
                        const match = line.match(/^\d+\.\s*(.+)$/);
                        if (match) {
                            taskTitles.push(match[1]);
                        }
                    }
                }
                
                // If no numbered list found, create generic tasks
                if (taskTitles.length === 0) {
                    for (let i = 1; i <= count; i++) {
                        taskTitles.push(`${category} Task ${i}`);
                    }
                }
                
                let createdCount = 0;
                for (const title of taskTitles.slice(0, count)) {
                    const response = await fetch('http://localhost:3001/api/tasks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title: title,
                            category: category,
                            status: 'pending',
                            priority: 'medium',
                            due_date: '2025-10-07'
                        })
                    });
                    if (response.ok) {
                        createdCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${createdCount} neue Tasks in der Kategorie "${category}" erstellt.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Erstellen der Tasks: ${error.message}`
                };
            }
        }

        async function moveTasksToDate(category, dateStr) {
            try {
                // Parse date string (e.g., "8.10" or "8.10.2025")
                let targetDate;
                if (dateStr.includes('.')) {
                    const parts = dateStr.split('.');
                    if (parts.length === 2) {
                        targetDate = `2025-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                    } else if (parts.length === 3) {
                        targetDate = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                    }
                }
                
                if (!targetDate) {
                    return {
                        executed: true,
                        message: `‚ùå Datum "${dateStr}" konnte nicht erkannt werden. Verwende Format: "8.10" oder "8.10.2025"`
                    };
                }
                
                const tasksToMove = allTasks.filter(task => 
                    task.category.toLowerCase() === category.toLowerCase() && 
                    task.status !== 'completed'
                );
                
                if (tasksToMove.length === 0) {
                    return {
                        executed: true,
                        message: `Keine ${category} Tasks gefunden.`
                    };
                }
                
                let movedCount = 0;
                for (const task of tasksToMove) {
                    const response = await fetch(`http://localhost:3001/api/tasks/${task.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ due_date: targetDate })
                    });
                    if (response.ok) {
                        movedCount++;
                    }
                }
                
                return {
                    executed: true,
                    message: `‚úÖ ${movedCount} ${category} Tasks auf ${dateStr} verschoben.`
                };
            } catch (error) {
                return {
                    executed: true,
                    message: `‚ùå Fehler beim Verschieben der Tasks: ${error.message}`
                };
            }
        }

        // Mistral AI Functions
        async function askMistral(prompt) {
            const chatMessages = document.getElementById('chatMessages');
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            
            // Add user message
            addMessage('user', prompt);
            
            // Clear input and disable send button
            chatInput.value = '';
            sendBtn.disabled = true;
            sendBtn.textContent = 'Sende...';
            
            try {
                // First, check if the prompt contains actionable commands
                const actionResult = await parseAndExecuteAction(prompt);
                if (actionResult.executed) {
                    addMessage('assistant', actionResult.message);
                    // Reload tasks to show changes
                    await loadTasks();
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Senden';
                    return;
                }
                
                // If no action was executed, proceed with normal Mistral chat
                const response = await fetch('http://localhost:3001/api/mistral', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ prompt: prompt })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Check if Mistral returned an action command
                    const actionResult = await parseMistralAction(data.response);
                    if (actionResult.executed) {
                        addMessage('assistant', actionResult.message);
                        // Reload tasks to show changes
                        await loadTasks();
                    } else {
                        addMessage('assistant', data.response);
                        
                        // Check if this was a tool execution (contains "Tool ausgef√ºhrt" or task operations)
                        if (data.response.includes('Tool ausgef√ºhrt') || 
                            data.response.includes('‚úÖ Tool ausgef√ºhrt') ||
                            data.response.includes('Task') && (data.response.includes('erstellt') || data.response.includes('gel√∂scht') || data.response.includes('verschoben'))) {
                            // Reload tasks after tool execution
                            await loadTasks();
                        }
                    }
                } else {
                    addMessage('assistant', `Fehler: ${data.error}`);
                }
            } catch (error) {
                console.error('Mistral API Fehler:', error);
                addMessage('assistant', 'Entschuldigung, es gab einen Fehler beim Verbinden mit Mistral.');
            } finally {
                sendBtn.disabled = false;
                sendBtn.textContent = 'Senden';
            }
        }

        // Send message
        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message) {
                askMistral(message);
            }
        }

        // Add message to chat
        function addMessage(sender, text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const now = new Date();
            const timeString = now.toLocaleTimeString('de-DE', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            messageDiv.innerHTML = `
                <div class="message-text">${text}</div>
                <div class="message-time">${timeString}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Daily Routine Functions
        async function createDailyRoutine() {
            addMessage('user', 'Erstelle Daily Routine f√ºr heute');
            
            try {
                const response = await fetch('http://localhost:3001/api/daily-routine/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ days: 1 })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addMessage('assistant', `‚úÖ Daily Routine erstellt! ${data.data.created} Datei(en) aktualisiert.`);
                    // Lade Tasks neu
                    loadTasks();
                } else {
                    addMessage('assistant', `‚ùå Fehler: ${data.error}`);
                }
            } catch (error) {
                console.error('Daily Routine API Fehler:', error);
                addMessage('assistant', 'Entschuldigung, es gab einen Fehler beim Erstellen der Daily Routine.');
            }
        }

        async function updateAllDailyRoutines() {
            addMessage('user', 'Aktualisiere alle Daily Routines');
            
            try {
                const response = await fetch('http://localhost:3001/api/daily-routine/update-all', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addMessage('assistant', `‚úÖ Alle Daily Routines aktualisiert! ${data.data.updated} Datei(en) bearbeitet.`);
                    // Lade Tasks neu
                    loadTasks();
                } else {
                    addMessage('assistant', `‚ùå Fehler: ${data.error}`);
                }
            } catch (error) {
                console.error('Daily Routine API Fehler:', error);
                addMessage('assistant', 'Entschuldigung, es gab einen Fehler beim Aktualisieren der Daily Routines.');
            }
        }

        async function getDailyRoutineStats() {
            try {
                const response = await fetch('http://localhost:3001/api/daily-routine/stats');
                const data = await response.json();
                
                if (data.success) {
                    addMessage('assistant', `üìä Daily Routine Statistiken:\n${data.data.stats}`);
                } else {
                    addMessage('assistant', `‚ùå Fehler: ${data.error}`);
                }
            } catch (error) {
                console.error('Daily Routine Stats Fehler:', error);
                addMessage('assistant', 'Entschuldigung, es gab einen Fehler beim Laden der Statistiken.');
            }
        }

        // Tab Memory Functions
        function saveActiveTab(tabName) {
            localStorage.setItem('todo-dashboard-active-tab', tabName);
        }

        function loadSavedTab() {
            const savedTab = localStorage.getItem('todo-dashboard-active-tab');
            if (savedTab && savedTab !== 'all') {
                // Simuliere Klick auf den gespeicherten Tab
                const tabButton = document.querySelector(`[onclick="filterTasks('${savedTab}')"]`);
                if (tabButton) {
                    // Kleine Verz√∂gerung, damit die Tasks bereits geladen sind
                    setTimeout(() => {
                        tabButton.click();
                    }, 100);
                }
            }
        }

        // Bulk Editor Functions
        function openBulkEditor() {
            addMessage('user', '√ñffne Bulk Editor f√ºr Kategorien und Priorit√§ten');
            
            const bulkEditorHTML = `
                <div style="background: var(--bg-primary); border: 1px solid var(--border-light); border-radius: var(--radius-lg); padding: var(--space-4); margin: var(--space-4) 0;">
                    <h4 style="margin: 0 0 var(--space-3) 0; color: var(--primary);">üìù Bulk Editor</h4>
                    
                    <div style="margin-bottom: var(--space-3);">
                        <label style="display: block; margin-bottom: var(--space-1); font-weight: 500;">Kategorie √§ndern:</label>
                        <select id="bulkCategory" style="width: 100%; padding: var(--space-2); border: 1px solid var(--border-medium); border-radius: var(--radius-md);">
                            <option value="">-- Kategorie ausw√§hlen --</option>
                            <option value="Business">Business</option>
                            <option value="Development">Development</option>
                            <option value="Marketing">Marketing</option>
                            <option value="PUSH">PUSH</option>
                            <option value="Personal">Personal</option>
                            <option value="General">General</option>
                            <option value="Check24">Check24</option>
                            <option value="Sustain">Sustain</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: var(--space-3);">
                        <label style="display: block; margin-bottom: var(--space-1); font-weight: 500;">Priorit√§t √§ndern:</label>
                        <select id="bulkPriority" style="width: 100%; padding: var(--space-2); border: 1px solid var(--border-medium); border-radius: var(--radius-md);">
                            <option value="">-- Priorit√§t ausw√§hlen --</option>
                            <option value="high">üî• Hoch</option>
                            <option value="medium">‚ö° Mittel (Standard)</option>
                            <option value="low">üåÖ Niedrig</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: var(--space-3);">
                        <label style="display: block; margin-bottom: var(--space-1); font-weight: 500;">Filter f√ºr Tasks:</label>
                        <select id="bulkFilter" style="width: 100%; padding: var(--space-2); border: 1px solid var(--border-medium); border-radius: var(--radius-md);">
                            <option value="all">Alle Tasks</option>
                            <option value="heute">Nur heutige Tasks</option>
                            <option value="hoch">Nur hochpriorit√§re Tasks</option>
                            <option value="√ºberf√§llig">Nur √ºberf√§llige Tasks</option>
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: var(--space-2);">
                        <button onclick="applyBulkChanges()" style="flex: 1; padding: var(--space-2) var(--space-3); background: var(--primary); color: white; border: none; border-radius: var(--radius-md); cursor: pointer;">Anwenden</button>
                        <button onclick="previewBulkChanges()" style="flex: 1; padding: var(--space-2) var(--space-3); background: var(--secondary-light); color: var(--text-primary); border: 1px solid var(--border-light); border-radius: var(--radius-md); cursor: pointer;">Vorschau</button>
                    </div>
                </div>
            `;
            
            addMessage('assistant', bulkEditorHTML);
        }

        function previewBulkChanges() {
            const category = document.getElementById('bulkCategory').value;
            const priority = document.getElementById('bulkPriority').value;
            const filter = document.getElementById('bulkFilter').value;
            
            if (!category && !priority) {
                addMessage('assistant', '‚ùå Bitte w√§hle mindestens eine Kategorie oder Priorit√§t aus.');
                return;
            }
            
            // Filtere Tasks basierend auf Auswahl
            let tasksToUpdate = [...allTasks];
            if (filter === 'heute') {
                tasksToUpdate = getTodayTasks();
            } else if (filter === 'hoch') {
                tasksToUpdate = allTasks.filter(task => task.priority === 'high');
            } else if (filter === '√ºberf√§llig') {
                tasksToUpdate = allTasks.filter(task => task.deadline_status === 'overdue');
            }
            
            const changes = [];
            tasksToUpdate.forEach(task => {
                const changesForTask = [];
                if (category && task.category !== category) {
                    changesForTask.push(`Kategorie: ${task.category} ‚Üí ${category}`);
                }
                if (priority && task.priority !== priority) {
                    changesForTask.push(`Priorit√§t: ${task.priority} ‚Üí ${priority}`);
                }
                if (changesForTask.length > 0) {
                    changes.push(`‚Ä¢ ${task.title}: ${changesForTask.join(', ')}`);
                }
            });
            
            if (changes.length === 0) {
                addMessage('assistant', '‚úÖ Keine √Ñnderungen erforderlich. Alle Tasks entsprechen bereits den gew√§hlten Kriterien.');
            } else {
                addMessage('assistant', `üìã **Vorschau der √Ñnderungen (${changes.length} Tasks):**\n\n${changes.slice(0, 10).join('\n')}${changes.length > 10 ? `\n\n... und ${changes.length - 10} weitere Tasks` : ''}`);
            }
        }

        function applyBulkChanges() {
            const category = document.getElementById('bulkCategory').value;
            const priority = document.getElementById('bulkPriority').value;
            const filter = document.getElementById('bulkFilter').value;
            
            if (!category && !priority) {
                addMessage('assistant', '‚ùå Bitte w√§hle mindestens eine Kategorie oder Priorit√§t aus.');
                return;
            }
            
            // Filtere Tasks basierend auf Auswahl
            let tasksToUpdate = [...allTasks];
            if (filter === 'heute') {
                tasksToUpdate = getTodayTasks();
            } else if (filter === 'hoch') {
                tasksToUpdate = allTasks.filter(task => task.priority === 'high');
            } else if (filter === '√ºberf√§llig') {
                tasksToUpdate = allTasks.filter(task => task.deadline_status === 'overdue');
            }
            
            let updatedCount = 0;
            tasksToUpdate.forEach(task => {
                let updated = false;
                if (category && task.category !== category) {
                    task.category = category;
                    updated = true;
                }
                if (priority && task.priority !== priority) {
                    task.priority = priority;
                    updated = true;
                }
                if (updated) {
                    updatedCount++;
                }
            });
            
            if (updatedCount === 0) {
                addMessage('assistant', '‚úÖ Keine √Ñnderungen erforderlich. Alle Tasks entsprechen bereits den gew√§hlten Kriterien.');
            } else {
                addMessage('assistant', `‚úÖ **${updatedCount} Tasks erfolgreich aktualisiert!**\n\nDie √Ñnderungen sind lokal gespeichert. Um sie dauerhaft zu machen, m√ºssen sie noch in die Markdown-Dateien synchronisiert werden.`);
                
                // Aktualisiere die Anzeige
                renderTasks();
                updateStats();
            }
        }

        function showCategoryStats() {
            addMessage('user', 'Zeige Kategorie- und Priorit√§ts-Statistiken');
            
            // Berechne Statistiken
            const categoryStats = {};
            const priorityStats = {};
            
            allTasks.forEach(task => {
                categoryStats[task.category] = (categoryStats[task.category] || 0) + 1;
                priorityStats[task.priority] = (priorityStats[task.priority] || 0) + 1;
            });
            
            const categoryHTML = Object.entries(categoryStats)
                .sort(([,a], [,b]) => b - a)
                .map(([category, count]) => `‚Ä¢ **${category}**: ${count} Tasks`)
                .join('\n');
                
            const priorityHTML = Object.entries(priorityStats)
                .map(([priority, count]) => `‚Ä¢ **${priority}**: ${count} Tasks`)
                .join('\n');
            
            addMessage('assistant', `üìä **Task-Statistiken:**\n\n**Kategorien:**\n${categoryHTML}\n\n**Priorit√§ten:**\n${priorityHTML}\n\n**Gesamt:** ${allTasks.length} Tasks`);
        }

        // Inline-Editing Functions
        function startEditTitle(taskId, currentTitle) {
            console.log('startEditTitle called with:', taskId, currentTitle);
            
            // Finde das Task-Element √ºber die Task-ID
            const taskElement = document.querySelector(`[ondragstart*="${taskId}"]`);
            console.log('taskElement found:', taskElement);
            
            if (!taskElement) {
                console.error('Task element not found for ID:', taskId);
                return;
            }
            
            // Finde die Elemente in der neuen Struktur
            const titleEditable = taskElement.querySelector('.task-title-editable');
            const titleText = taskElement.querySelector('.task-title-text');
            const titleInput = taskElement.querySelector('.task-title-edit');
            
            console.log('titleEditable:', titleEditable, 'titleText:', titleText, 'titleInput:', titleInput);
            
            if (!titleEditable || !titleText || !titleInput) {
                console.error('Title elements not found');
                return;
            }
            
            // Verstecke das editable Element und zeige das Input-Feld
            titleEditable.style.display = 'none';
            titleInput.style.display = 'inline-block';
            titleInput.value = currentTitle;
            titleInput.focus();
            titleInput.select();
        }

        function saveEditTitle(taskId) {
            // Finde das Task-Element √ºber die Task-ID
            const taskElement = document.querySelector(`[ondragstart*="${taskId}"]`);
            
            if (!taskElement) {
                console.error('Task element not found for ID:', taskId);
                return;
            }
            
            const titleEditable = taskElement.querySelector('.task-title-editable');
            const titleText = taskElement.querySelector('.task-title-text');
            const titleInput = taskElement.querySelector('.task-title-edit');
            const newTitle = titleInput.value.trim();
            
            if (newTitle && newTitle !== titleText.textContent) {
                updateTask(taskId, { title: newTitle });
            }
            
            // Zeige das editable Element wieder und verstecke das Input-Feld
            titleEditable.style.display = 'flex';
            titleInput.style.display = 'none';
        }

        function handleEditKeypress(event, taskId) {
            if (event.key === 'Enter') {
                saveEditTitle(taskId);
            } else if (event.key === 'Escape') {
                // Finde das Task-Element √ºber die Task-ID
                const taskElement = document.querySelector(`[ondragstart*="${taskId}"]`);
                
                if (!taskElement) {
                    console.error('Task element not found for ID:', taskId);
                    return;
                }
                
                const titleEditable = taskElement.querySelector('.task-title-editable');
                const titleInput = taskElement.querySelector('.task-title-edit');
                
                // Zeige das editable Element wieder und verstecke das Input-Feld
                titleEditable.style.display = 'flex';
                titleInput.style.display = 'none';
            }
        }

        function startEditPriority(taskId, currentPriority) {
            const priorities = ['low', 'medium', 'high'];
            const currentIndex = priorities.indexOf(currentPriority);
            const nextIndex = (currentIndex + 1) % priorities.length;
            const newPriority = priorities[nextIndex];
            
            updateTask(taskId, { priority: newPriority });
        }

        function startEditCategory(taskId, currentCategory) {
            const newCategory = prompt(`Neue Kategorie f√ºr Task "${currentCategory}":`, currentCategory);
            if (newCategory && newCategory.trim() !== currentCategory) {
                updateTask(taskId, { category: newCategory.trim() });
            }
        }

        function startEditDueDate(taskId, currentDueDate) {
            const newDueDate = prompt(`Neues F√§lligkeitsdatum f√ºr Task:`, currentDueDate);
            if (newDueDate && newDueDate !== currentDueDate) {
                updateTask(taskId, { due_date: newDueDate });
            }
        }

        // Context Menu Functions
        function showPriorityMenu(taskId, currentPriority, event) {
            closeAllContextMenus();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            const priorities = [
                { value: 'low', label: 'Niedrig', icon: 'üîµ' },
                { value: 'medium', label: 'Mittel', icon: 'üü°' },
                { value: 'high', label: 'Hoch', icon: 'üî¥' }
            ];
            
            priorities.forEach(priority => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                if (priority.value === currentPriority) {
                    item.style.backgroundColor = 'var(--primary-light)';
                }
                item.innerHTML = `${priority.icon} ${priority.label}`;
                item.onclick = () => {
                    updateTask(taskId, { priority: priority.value });
                    closeAllContextMenus();
                };
                menu.appendChild(item);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeAllContextMenus, { once: true });
            }, 0);
        }

        function showCategoryMenu(taskId, currentCategory, event) {
            closeAllContextMenus();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            // Get existing categories
            const categories = [...new Set(allTasks.map(task => task.category))].sort();
            
            categories.forEach(category => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                if (category === currentCategory) {
                    item.style.backgroundColor = 'var(--primary-light)';
                }
                item.innerHTML = `üìÅ ${category}`;
                item.onclick = () => {
                    updateTask(taskId, { category: category });
                    closeAllContextMenus();
                };
                menu.appendChild(item);
            });
            
            // Add "New Category" option
            const newItem = document.createElement('div');
            newItem.className = 'context-menu-item';
            newItem.innerHTML = '‚ûï Neue Kategorie';
            newItem.onclick = () => {
                const newCategory = prompt('Neue Kategorie:', '');
                if (newCategory && newCategory.trim()) {
                    updateTask(taskId, { category: newCategory.trim() });
                }
                closeAllContextMenus();
            };
            menu.appendChild(newItem);
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeAllContextMenus, { once: true });
            }, 0);
        }

        function showDateMenu(taskId, currentDueDate, event) {
            closeAllContextMenus();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            const nextWeek = new Date(today);
            nextWeek.setDate(today.getDate() + 7);
            
            const dateOptions = [
                { label: 'Heute', date: today.toISOString().split('T')[0], icon: 'üìÖ' },
                { label: 'Morgen', date: tomorrow.toISOString().split('T')[0], icon: 'üìÖ' },
                { label: 'N√§chste Woche', date: nextWeek.toISOString().split('T')[0], icon: 'üìÖ' }
            ];
            
            dateOptions.forEach(option => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                if (option.date === currentDueDate) {
                    item.style.backgroundColor = 'var(--primary-light)';
                }
                item.innerHTML = `${option.icon} ${option.label}`;
                item.onclick = () => {
                    updateTask(taskId, { due_date: option.date });
                    closeAllContextMenus();
                };
                menu.appendChild(item);
            });
            
            // Add custom date picker
            const customItem = document.createElement('div');
            customItem.className = 'context-menu-item';
            customItem.innerHTML = 'üìÖ Benutzerdefiniert';
            customItem.onclick = () => {
                const input = document.createElement('input');
                input.type = 'date';
                input.value = currentDueDate || '';
                input.onchange = () => {
                    if (input.value) {
                        updateTask(taskId, { due_date: input.value });
                    }
                    closeAllContextMenus();
                };
                input.click();
            };
            menu.appendChild(customItem);
            
            // Add "Remove Date" option
            if (currentDueDate) {
                const removeItem = document.createElement('div');
                removeItem.className = 'context-menu-item danger';
                removeItem.innerHTML = 'üóëÔ∏è Datum entfernen';
                removeItem.onclick = () => {
                    updateTask(taskId, { due_date: null });
                    closeAllContextMenus();
                };
                menu.appendChild(removeItem);
            }
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeAllContextMenus, { once: true });
            }, 0);
        }

        function closeAllContextMenus() {
            const menus = document.querySelectorAll('.context-menu');
            menus.forEach(menu => menu.remove());
        }

        function saveEditTitle(taskId) {
            // Finde das Task-Element √ºber die Task-ID
            const taskElement = document.querySelector(`[ondragstart*="${taskId}"]`);
            
            if (!taskElement) {
                console.error('Task element not found for ID:', taskId);
                return;
            }
            
            const titleEditable = taskElement.querySelector('.task-title-editable');
            const titleText = taskElement.querySelector('.task-title-text');
            const titleInput = taskElement.querySelector('.task-title-edit');
            const newTitle = titleInput.value.trim();
            
            if (newTitle && newTitle !== titleText.textContent) {
                updateTask(taskId, { title: newTitle });
            }
            
            // Zeige das editable Element wieder und verstecke das Input-Feld
            titleEditable.style.display = 'flex';
            titleInput.style.display = 'none';
        }

        function handleEditKeypress(event, taskId) {
            if (event.key === 'Enter') {
                saveEditTitle(taskId);
            } else if (event.key === 'Escape') {
                // Finde das Task-Element √ºber die Task-ID
                const taskElement = document.querySelector(`[ondragstart*="${taskId}"]`);
                
                if (!taskElement) {
                    console.error('Task element not found for ID:', taskId);
                    return;
                }
                
                const titleEditable = taskElement.querySelector('.task-title-editable');
                const titleInput = taskElement.querySelector('.task-title-edit');
                
                // Zeige das editable Element wieder und verstecke das Input-Feld
                titleEditable.style.display = 'flex';
                titleInput.style.display = 'none';
            }
        }

        function startEditPriority(taskId, currentPriority) {
            const priorities = ['low', 'medium', 'high'];
            const currentIndex = priorities.indexOf(currentPriority);
            const nextIndex = (currentIndex + 1) % priorities.length;
            const newPriority = priorities[nextIndex];
            
            updateTask(taskId, { priority: newPriority });
        }

        function startEditCategory(taskId, currentCategory) {
            const newCategory = prompt(`Neue Kategorie f√ºr Task "${currentCategory}":`, currentCategory);
            if (newCategory && newCategory.trim() !== currentCategory) {
                updateTask(taskId, { category: newCategory.trim() });
            }
        }

        function startEditDueDate(taskId, currentDueDate) {
            const newDueDate = prompt(`Neues F√§lligkeitsdatum f√ºr Task:`, currentDueDate);
            if (newDueDate && newDueDate !== currentDueDate) {
                updateTask(taskId, { due_date: newDueDate });
            }
        }

        // Context Menu Functions
        function showPriorityMenu(taskId, currentPriority, event) {
            closeAllContextMenus();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            const priorities = [
                { value: 'low', label: 'Niedrig', icon: 'üîµ' },
                { value: 'medium', label: 'Mittel', icon: 'üü°' },
                { value: 'high', label: 'Hoch', icon: 'üî¥' }
            ];
            
            priorities.forEach(priority => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                if (priority.value === currentPriority) {
                    item.style.backgroundColor = 'var(--primary-light)';
                }
                item.innerHTML = `${priority.icon} ${priority.label}`;
                item.onclick = () => {
                    updateTask(taskId, { priority: priority.value });
                    closeAllContextMenus();
                };
                menu.appendChild(item);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeAllContextMenus, { once: true });
            }, 0);
        }

        function showCategoryMenu(taskId, currentCategory, event) {
            closeAllContextMenus();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            // Get existing categories
            const categories = [...new Set(allTasks.map(task => task.category))].sort();
            
            categories.forEach(category => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                if (category === currentCategory) {
                    item.style.backgroundColor = 'var(--primary-light)';
                }
                item.innerHTML = `üìÅ ${category}`;
                item.onclick = () => {
                    updateTask(taskId, { category: category });
                    closeAllContextMenus();
                };
                menu.appendChild(item);
            });
            
            // Add "New Category" option
            const newItem = document.createElement('div');
            newItem.className = 'context-menu-item';
            newItem.innerHTML = '‚ûï Neue Kategorie';
            newItem.onclick = () => {
                const newCategory = prompt('Neue Kategorie:', '');
                if (newCategory && newCategory.trim()) {
                    updateTask(taskId, { category: newCategory.trim() });
                }
                closeAllContextMenus();
            };
            menu.appendChild(newItem);
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeAllContextMenus, { once: true });
            }, 0);
        }

        function showDateMenu(taskId, currentDueDate, event) {
            closeAllContextMenus();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            const nextWeek = new Date(today);
            nextWeek.setDate(today.getDate() + 7);
            
            const dateOptions = [
                { label: 'Heute', date: today.toISOString().split('T')[0], icon: 'üìÖ' },
                { label: 'Morgen', date: tomorrow.toISOString().split('T')[0], icon: 'üìÖ' },
                { label: 'N√§chste Woche', date: nextWeek.toISOString().split('T')[0], icon: 'üìÖ' }
            ];
            
            dateOptions.forEach(option => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                if (option.date === currentDueDate) {
                    item.style.backgroundColor = 'var(--primary-light)';
                }
                item.innerHTML = `${option.icon} ${option.label}`;
                item.onclick = () => {
                    updateTask(taskId, { due_date: option.date });
                    closeAllContextMenus();
                };
                menu.appendChild(item);
            });
            
            // Add custom date picker
            const customItem = document.createElement('div');
            customItem.className = 'context-menu-item';
            customItem.innerHTML = 'üìÖ Benutzerdefiniert';
            customItem.onclick = () => {
                const input = document.createElement('input');
                input.type = 'date';
                input.value = currentDueDate || '';
                input.onchange = () => {
                    if (input.value) {
                        updateTask(taskId, { due_date: input.value });
                    }
                    closeAllContextMenus();
                };
                input.click();
            };
            menu.appendChild(customItem);
            
            // Add "Remove Date" option
            if (currentDueDate) {
                const removeItem = document.createElement('div');
                removeItem.className = 'context-menu-item danger';
                removeItem.innerHTML = 'üóëÔ∏è Datum entfernen';
                removeItem.onclick = () => {
                    updateTask(taskId, { due_date: null });
                    closeAllContextMenus();
                };
                menu.appendChild(removeItem);
            }
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeAllContextMenus, { once: true });
            }, 0);
        }

        function closeAllContextMenus() {
            const menus = document.querySelectorAll('.context-menu');
            menus.forEach(menu => menu.remove());
        }

        // Universal Task Update Function
        async function updateTask(taskId, updates) {
            try {
                const response = await fetch(`/api/tasks/${taskId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });
                
                if (response.ok) {
                    // Update local data
                    const task = allTasks.find(t => t.id === taskId);
                    if (task) {
                        Object.assign(task, updates);
                        renderTasks();
                    }
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error updating task:', error);
                return false;
            }
        }

        // Simplified Inline-Editing Functions


        function handleEditKeypress(event, taskId) {
            if (event.key === 'Enter') {
                saveEditTitle(taskId);
            } else if (event.key === 'Escape') {
                // Finde das Task-Element √ºber die Task-ID
                const taskElement = document.querySelector(`[ondragstart*="${taskId}"]`);
                
                if (!taskElement) {
                    console.error('Task element not found for ID:', taskId);
                    return;
                }
                
                const titleEditable = taskElement.querySelector('.task-title-editable');
                const titleInput = taskElement.querySelector('.task-title-edit');
                
                // Zeige das editable Element wieder und verstecke das Input-Feld
                titleEditable.style.display = 'flex';
                titleInput.style.display = 'none';
            }
        }

        function startEditPriority(taskId, currentPriority) {
            const priorities = ['low', 'medium', 'high'];
            const currentIndex = priorities.indexOf(currentPriority);
            const nextIndex = (currentIndex + 1) % priorities.length;
            const newPriority = priorities[nextIndex];
            
            updateTask(taskId, { priority: newPriority });
        }

        function startEditCategory(taskId, currentCategory) {
            const newCategory = prompt(`Neue Kategorie f√ºr Task "${currentCategory}":`, currentCategory);
            if (newCategory && newCategory.trim() !== currentCategory) {
                updateTask(taskId, { category: newCategory.trim() });
            }
        }


        // Modal Management Functions
        function openTaskCreationModal() {
            document.getElementById('taskCreationModal').style.display = 'flex';
            document.getElementById('taskTitle').focus();
        }

        function closeTaskCreationModal() {
            document.getElementById('taskCreationModal').style.display = 'none';
            document.getElementById('taskForm').reset();
        }

        function openCategoryManagementModal() {
            document.getElementById('categoryManagementModal').style.display = 'flex';
            loadCategories();
        }

        function closeCategoryManagementModal() {
            document.getElementById('categoryManagementModal').style.display = 'none';
        }

        function submitTaskForm() {
            const form = document.getElementById('taskForm');
            const formData = new FormData(form);
            const taskData = {
                title: formData.get('title'),
                category: formData.get('category'),
                priority: formData.get('priority'),
                due_date: formData.get('dueDate') || null
            };
            
            createTaskFromModal(taskData);
        }

        async function createTaskFromModal(taskData) {
            try {
                const response = await fetch('/api/tasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(taskData)
                });
                
                if (response.ok) {
                    closeTaskCreationModal();
                    await loadTasks();
                    addMessage('assistant', `‚úÖ Task "${taskData.title}" erfolgreich erstellt!`);
                } else {
                    addMessage('assistant', '‚ùå Fehler beim Erstellen des Tasks.');
                }
            } catch (error) {
                console.error('Error creating task:', error);
                addMessage('assistant', '‚ùå Fehler beim Erstellen des Tasks.');
            }
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(event) {
            if (event.target.classList.contains('modal-overlay')) {
                closeTaskCreationModal();
                closeCategoryManagementModal();
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeTaskCreationModal();
                closeCategoryManagementModal();
            }
        });


        async function loadCategories() {
            try {
                const response = await fetch('/api/smart-tasks');
                const data = await response.json();
                
                // Get unique categories
                const categories = [...new Set(data.tasks.map(task => task.category))].sort();
                
                const categoryList = document.getElementById('categoryList');
                categoryList.innerHTML = categories.map(category => `
                    <div class="category-item">
                        <span class="category-name">${category}</span>
                        <div class="category-buttons">
                            <button class="btn btn-small btn-secondary" onclick="renameCategory('${category}')">Umbenennen</button>
                            <button class="btn btn-small btn-danger" onclick="deleteCategory('${category}')">L√∂schen</button>
                        </div>
                    </div>
                `).join('');
                
                // Update task creation form categories
                updateTaskFormCategories(categories);
            } catch (error) {
                console.error('Error loading categories:', error);
            }
        }

        function updateTaskFormCategories(categories) {
            const select = document.getElementById('taskCategory');
            select.innerHTML = categories.map(category => 
                `<option value="${category}">${category}</option>`
            ).join('');
        }

        async function createCategory() {
            const categoryName = document.getElementById('newCategoryName').value.trim();
            if (!categoryName) return;
            
            try {
                const response = await fetch('/api/mistral', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: `Erstelle eine neue Kategorie namens "${categoryName}"`
                    })
                });
                
                if (response.ok) {
                    document.getElementById('newCategoryName').value = '';
                    await loadCategories();
                    addMessage('assistant', `‚úÖ Kategorie "${categoryName}" erfolgreich erstellt!`);
                } else {
                    addMessage('assistant', '‚ùå Fehler beim Erstellen der Kategorie.');
                }
            } catch (error) {
                console.error('Error creating category:', error);
                addMessage('assistant', '‚ùå Fehler beim Erstellen der Kategorie.');
            }
        }

        async function renameCategory(oldName) {
            const newName = prompt(`Neuer Name f√ºr Kategorie "${oldName}":`, oldName);
            if (!newName || newName === oldName) return;
            
            try {
                const response = await fetch('/api/mistral', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: `Benenne die Kategorie "${oldName}" um zu "${newName}"`
                    })
                });
                
                if (response.ok) {
                    await loadCategories();
                    await loadTasks();
                    addMessage('assistant', `‚úÖ Kategorie "${oldName}" erfolgreich umbenannt zu "${newName}"!`);
                } else {
                    addMessage('assistant', '‚ùå Fehler beim Umbenennen der Kategorie.');
                }
            } catch (error) {
                console.error('Error renaming category:', error);
                addMessage('assistant', '‚ùå Fehler beim Umbenennen der Kategorie.');
            }
        }

        async function deleteCategory(categoryName) {
            if (!confirm(`M√∂chten Sie wirklich alle Tasks der Kategorie "${categoryName}" l√∂schen?`)) {
                return;
            }
            
            try {
                const response = await fetch('/api/mistral', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: `L√∂sche alle Tasks der Kategorie "${categoryName}"`
                    })
                });
                
                if (response.ok) {
                    await loadCategories();
                    await loadTasks();
                    addMessage('assistant', `‚úÖ Alle Tasks der Kategorie "${categoryName}" wurden gel√∂scht!`);
                } else {
                    addMessage('assistant', '‚ùå Fehler beim L√∂schen der Kategorie.');
                }
            } catch (error) {
                console.error('Error deleting category:', error);
                addMessage('assistant', '‚ùå Fehler beim L√∂schen der Kategorie.');
            }
        }

        // Due Date Inline-Editing

    </script>
</body>
</html>