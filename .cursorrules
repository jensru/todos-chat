# Cursor AI Development Rules

## TypeScript Strict Rules (Vercel Build Requirements)

### Parameter Handling
- ALWAYS prefix unused parameters with underscore: `_request: NextRequest`
- NEVER leave unused parameters without underscore prefix
- Use proper TypeScript types, avoid `any` when possible

### Function & Variable Handling
- ALWAYS prefix unused functions with underscore: `_handleDragOver`
- ALWAYS prefix unused variables with underscore: `_attributes`, `_listeners`
- ALWAYS prefix unused event parameters with underscore: `_e`, `_event`
- Use destructuring with underscore: `{ attributes: _attributes, listeners: _listeners }`
- Remove unused variable declarations completely if not needed

### Optional Properties
- For optional boolean props, use nullish coalescing: `isNewTask={isNewTask ?? false}`
- Optional properties cannot be `undefined` with `exactOptionalPropertyTypes: true`
- Always handle optional props explicitly

### Function Signatures
- ALWAYS specify explicit return types: `Promise<void>`, `NextResponse`, etc.
- Use proper parameter types: `Partial<Task>`, not `any`
- Mark optional parameters with `?`: `param?: Type`

### Component Props
- Use `I` prefix for interfaces: `ITaskCardProps`
- Handle optional props properly with nullish coalescing
- Ensure boolean props are always `boolean`, never `boolean | undefined`

### API Routes
- Prefix unused request parameters: `_request: NextRequest`
- Use proper response types: `NextResponse`
- Handle errors with proper TypeScript types

## Common Patterns to Follow

```typescript
// ✅ Correct - Unused parameters
function handler(_request: NextRequest): Promise<NextResponse> { ... }

// ✅ Correct - Unused functions
const _handleDragOver = (_event: DragOverEvent) => { ... }

// ✅ Correct - Unused event parameters
onTouchStart={(_e) => { ... }}
onClick={(_event) => { ... }}

// ✅ Correct - Unused variables in destructuring
const { attributes: _attributes, listeners: _listeners } = useSortable();

// ✅ Correct - Remove unused variables completely
// ❌ Bad: const touch = e.touches[0]; // unused
// ✅ Good: const startTime = Date.now(); // only what you need

// ✅ Correct - Optional boolean props
isNewTask={isNewTask ?? false}

// ✅ Correct - Function signatures
function updateTask(id: string, updates: Partial<Task>): Promise<void> { ... }

// ✅ Correct - Interface definitions
interface ITaskCardProps {
  task: Task;
  isNewTask?: boolean;
}
```

## Strict TypeScript Rules
- `noUnusedParameters: true` - Prefix unused params with `_`
- `noUnusedLocals: true` - Prefix unused variables/functions with `_`
- `exactOptionalPropertyTypes: true` - Optional props cannot be `undefined`
- `noImplicitReturns: true` - All code paths must return
- `noFallthroughCasesInSwitch: true` - No fallthrough in switch cases

## Before Every Code Change
1. Check for unused parameters → prefix with `_`
2. Check for unused functions/variables → prefix with `_`
3. Check for unused event parameters → prefix with `_`
4. Check destructuring assignments → prefix unused with `_`
5. Remove unused variable declarations completely
6. Check optional boolean props → use `?? false`
7. Check function return types → make explicit
8. Check interface definitions → use `I` prefix
9. Check for ESLint warnings → remove unused directives

## Project Context
- Next.js 15 with App Router
- Supabase for backend and auth
- Mistral AI for intelligent task management
- Auto-save system with visual feedback
- Multi-language support (60+ languages)
- Strict TypeScript configuration for Vercel builds

## Code Quality
- Follow these rules to prevent Vercel build failures
- Maintain high code quality standards
- Use proper TypeScript patterns consistently
- Avoid common pitfalls that cause build errors

Remember: Vercel uses the same strict TypeScript rules, so following these patterns locally prevents production build failures.
